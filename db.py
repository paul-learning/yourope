import sqlite3
from typing import Dict, Any, List, Tuple, Optional
import json
import os
import base64
import hashlib

from utils import clamp_int

DB_PATH = "game.db"


def get_conn() -> sqlite3.Connection:
    return sqlite3.connect(DB_PATH, check_same_thread=False)


def _col_exists(conn: sqlite3.Connection, table: str, col: str) -> bool:
    cur = conn.cursor()
    cur.execute(f"PRAGMA table_info({table})")
    cols = [r[1] for r in cur.fetchall()]
    return col in cols


def ensure_schema(conn: sqlite3.Connection) -> None:
    cur = conn.cursor()

    # Countries
    cur.execute("""
    CREATE TABLE IF NOT EXISTS countries (
        name TEXT PRIMARY KEY,
        military INTEGER NOT NULL,
        stability INTEGER NOT NULL,
        economy INTEGER NOT NULL,
        diplomatic_influence INTEGER NOT NULL,
        public_approval INTEGER NOT NULL,
        ambition TEXT NOT NULL
    )
    """)

    # Turn history
    cur.execute("""
    CREATE TABLE IF NOT EXISTS turn_history (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        ts DATETIME DEFAULT CURRENT_TIMESTAMP,
        country TEXT NOT NULL,
        round INTEGER NOT NULL,
        action_public TEXT NOT NULL,
        global_context TEXT NOT NULL,
        delta_military INTEGER NOT NULL,
        delta_stability INTEGER NOT NULL,
        delta_economy INTEGER NOT NULL,
        delta_diplomatic_influence INTEGER NOT NULL,
        delta_public_approval INTEGER NOT NULL
    )
    """)

    # EU state (persisted)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS eu_state (
        id INTEGER PRIMARY KEY CHECK (id = 1),
        cohesion INTEGER NOT NULL,
        global_context TEXT NOT NULL
    )
    """)

    # --- Migration for eu_state extra columns ---
    if not _col_exists(conn, "eu_state", "threat_level"):
        cur.execute("ALTER TABLE eu_state ADD COLUMN threat_level INTEGER NOT NULL DEFAULT 35")
    if not _col_exists(conn, "eu_state", "frontline_pressure"):
        cur.execute("ALTER TABLE eu_state ADD COLUMN frontline_pressure INTEGER NOT NULL DEFAULT 30")
    if not _col_exists(conn, "eu_state", "energy_pressure"):
        cur.execute("ALTER TABLE eu_state ADD COLUMN energy_pressure INTEGER NOT NULL DEFAULT 25")
    if not _col_exists(conn, "eu_state", "migration_pressure"):
        cur.execute("ALTER TABLE eu_state ADD COLUMN migration_pressure INTEGER NOT NULL DEFAULT 25")
    if not _col_exists(conn, "eu_state", "disinfo_pressure"):
        cur.execute("ALTER TABLE eu_state ADD COLUMN disinfo_pressure INTEGER NOT NULL DEFAULT 25")
    if not _col_exists(conn, "eu_state", "trade_war_pressure"):
        cur.execute("ALTER TABLE eu_state ADD COLUMN trade_war_pressure INTEGER NOT NULL DEFAULT 25")

    # Game meta (round/phase)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS game_meta (
        id INTEGER PRIMARY KEY CHECK (id = 1),
        round INTEGER NOT NULL,
        phase TEXT NOT NULL
    )
    """)

    # --- Migration: Game Over fields ---
    if not _col_exists(conn, "game_meta", "winner_country"):
        cur.execute("ALTER TABLE game_meta ADD COLUMN winner_country TEXT")
    if not _col_exists(conn, "game_meta", "winner_round"):
        cur.execute("ALTER TABLE game_meta ADD COLUMN winner_round INTEGER")
    if not _col_exists(conn, "game_meta", "winner_reason"):
        cur.execute("ALTER TABLE game_meta ADD COLUMN winner_reason TEXT")

    # Round actions (generated by GM, then published)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS round_actions (
        round INTEGER NOT NULL,
        country TEXT NOT NULL,
        variant TEXT NOT NULL,
        action_text TEXT NOT NULL,
        PRIMARY KEY (round, country, variant)
    )
    """)

    # --- Migration: impact_json for action previews ---
    if not _col_exists(conn, "round_actions", "impact_json"):
        cur.execute("ALTER TABLE round_actions ADD COLUMN impact_json TEXT")

    # Locks (players lock choice)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS round_locks (
        round INTEGER NOT NULL,
        country TEXT NOT NULL,
        locked_variant TEXT NOT NULL,
        locked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (round, country)
    )
    """)

    # Round summaries (Stufe 2 Memory)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS round_summaries (
        round INTEGER PRIMARY KEY,
        summary TEXT NOT NULL,
        ts DATETIME DEFAULT CURRENT_TIMESTAMP
    )
    """)

    # External events (USA/China/Russia) per round
    cur.execute("""
    CREATE TABLE IF NOT EXISTS external_events (
        round INTEGER NOT NULL,
        actor TEXT NOT NULL,
        headline TEXT NOT NULL,
        modifiers_json TEXT NOT NULL,
        PRIMARY KEY (round, actor)
    )
    """)

        # Domestic events (innenpolitische Headlines) per round + country
    cur.execute("""
    CREATE TABLE IF NOT EXISTS domestic_events (
        round INTEGER NOT NULL,
        country TEXT NOT NULL,
        headline TEXT NOT NULL,
        details TEXT NOT NULL DEFAULT '',
        craziness INTEGER NOT NULL DEFAULT 0,
        created_at INTEGER NOT NULL DEFAULT 0,
        PRIMARY KEY (round, country)
    )
    """)

    # migrations for older DBs
    if not _col_exists(conn, "domestic_events", "details"):
        cur.execute("ALTER TABLE domestic_events ADD COLUMN details TEXT NOT NULL DEFAULT ''")
    if not _col_exists(conn, "domestic_events", "craziness"):
        cur.execute("ALTER TABLE domestic_events ADD COLUMN craziness INTEGER NOT NULL DEFAULT 0")
    if not _col_exists(conn, "domestic_events", "created_at"):
        # SQLite ALTER TABLE needs constant defaults
        cur.execute("ALTER TABLE domestic_events ADD COLUMN created_at INTEGER NOT NULL DEFAULT 0")


    # --- NEW migrations: quote + craziness for external events ---
    if not _col_exists(conn, "external_events", "quote"):
        cur.execute("ALTER TABLE external_events ADD COLUMN quote TEXT NOT NULL DEFAULT ''")
    if not _col_exists(conn, "external_events", "craziness"):
        cur.execute("ALTER TABLE external_events ADD COLUMN craziness INTEGER NOT NULL DEFAULT 0")

    # Users (auth)
    cur.execute("""
    CREATE TABLE IF NOT EXISTS users (
        username TEXT PRIMARY KEY,
        password_hash TEXT NOT NULL,
        role TEXT NOT NULL,          -- "gm" oder "player"
        country TEXT,               -- nur für player: z.B. "Germany"
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
    )
    """)

    # --- NEW: Country snapshots for public dashboard ---
    cur.execute("""
    CREATE TABLE IF NOT EXISTS country_snapshots (
        round INTEGER NOT NULL,
        country TEXT NOT NULL,
        economy INTEGER NOT NULL,
        stability INTEGER NOT NULL,
        military INTEGER NOT NULL,
        diplomatic_influence INTEGER NOT NULL,
        public_approval INTEGER NOT NULL,
        victory_progress REAL NOT NULL DEFAULT 0,
        is_winner INTEGER NOT NULL DEFAULT 0,
        ts DATETIME DEFAULT CURRENT_TIMESTAMP,
        PRIMARY KEY (round, country)
    )
    """)

    conn.commit()

    # Seed eu_state & game_meta
    cur.execute("SELECT 1 FROM eu_state WHERE id = 1")
    if cur.fetchone() is None:
        cur.execute("""
            INSERT INTO eu_state (
                id, cohesion, global_context,
                threat_level, frontline_pressure,
                energy_pressure, migration_pressure, disinfo_pressure, trade_war_pressure
            )
            VALUES (1, 75, '', 35, 30, 25, 25, 25, 25)
        """)

    cur.execute("SELECT 1 FROM game_meta WHERE id = 1")
    if cur.fetchone() is None:
        # phases: setup -> external_generated -> actions_generated -> actions_published -> game_over
        cur.execute("INSERT INTO game_meta (id, round, phase) VALUES (1, 1, 'setup')")

    conn.commit()


def seed_countries_if_missing(conn: sqlite3.Connection, country_defs: Dict[str, Dict[str, Any]]) -> None:
    cur = conn.cursor()
    for name, data in country_defs.items():
        cur.execute("SELECT 1 FROM countries WHERE name = ?", (name,))
        if cur.fetchone() is None:
            cur.execute("""
                INSERT INTO countries (name, military, stability, economy, diplomatic_influence, public_approval, ambition)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (
                name,
                int(data["military"]),
                int(data["stability"]),
                int(data["economy"]),
                int(data["diplomatic_influence"]),
                int(data["public_approval"]),
                str(data["ambition"]),
            ))
    conn.commit()


def reset_country_to_defaults(conn: sqlite3.Connection, country: str, defaults: Dict[str, Any]) -> None:
    cur = conn.cursor()
    cur.execute("""
        UPDATE countries SET
            military = ?,
            stability = ?,
            economy = ?,
            diplomatic_influence = ?,
            public_approval = ?,
            ambition = ?
        WHERE name = ?
    """, (
        int(defaults["military"]),
        int(defaults["stability"]),
        int(defaults["economy"]),
        int(defaults["diplomatic_influence"]),
        int(defaults["public_approval"]),
        str(defaults["ambition"]),
        country,
    ))
    cur.execute("DELETE FROM turn_history WHERE country = ?", (country,))
    conn.commit()


def reset_all_countries(conn: sqlite3.Connection, country_defs: Dict[str, Dict[str, Any]]) -> None:
    for country, defs in country_defs.items():
        reset_country_to_defaults(conn, country, defs)


# -----------------------
# EU + META
# -----------------------
def get_eu_state(conn: sqlite3.Connection) -> Dict[str, Any]:
    cur = conn.cursor()
    cur.execute("""
        SELECT cohesion, global_context,
               threat_level, frontline_pressure,
               energy_pressure, migration_pressure, disinfo_pressure, trade_war_pressure
        FROM eu_state WHERE id = 1
    """)
    row = cur.fetchone()
    cohesion, global_context, threat, frontline, energy, migr, disinfo, trade = row
    return {
        "cohesion": int(cohesion),
        "global_context": str(global_context),
        "threat_level": int(threat),
        "frontline_pressure": int(frontline),
        "energy_pressure": int(energy),
        "migration_pressure": int(migr),
        "disinfo_pressure": int(disinfo),
        "trade_war_pressure": int(trade),
    }


def set_eu_state(
    conn: sqlite3.Connection,
    *,
    cohesion: int,
    global_context: str,
    threat_level: int,
    frontline_pressure: int,
    energy_pressure: int,
    migration_pressure: int,
    disinfo_pressure: int,
    trade_war_pressure: int,
) -> None:
    cur = conn.cursor()
    cur.execute("""
        UPDATE eu_state SET
            cohesion = ?,
            global_context = ?,
            threat_level = ?,
            frontline_pressure = ?,
            energy_pressure = ?,
            migration_pressure = ?,
            disinfo_pressure = ?,
            trade_war_pressure = ?
        WHERE id = 1
    """, (
        clamp_int(int(cohesion), 0, 100),
        str(global_context),
        clamp_int(int(threat_level), 0, 100),
        clamp_int(int(frontline_pressure), 0, 100),
        clamp_int(int(energy_pressure), 0, 100),
        clamp_int(int(migration_pressure), 0, 100),
        clamp_int(int(disinfo_pressure), 0, 100),
        clamp_int(int(trade_war_pressure), 0, 100),
    ))
    conn.commit()


def get_game_meta(conn: sqlite3.Connection) -> Dict[str, Any]:
    cur = conn.cursor()
    cur.execute("SELECT round, phase, winner_country, winner_round, winner_reason FROM game_meta WHERE id = 1")
    r, p, wc, wr, wrea = cur.fetchone()
    return {
        "round": int(r),
        "phase": str(p),
        "winner_country": (str(wc) if wc else None),
        "winner_round": (int(wr) if wr is not None else None),
        "winner_reason": (str(wrea) if wrea else None),
    }


def set_game_meta(conn: sqlite3.Connection, round_no: int, phase: str) -> None:
    cur = conn.cursor()
    cur.execute("UPDATE game_meta SET round = ?, phase = ? WHERE id = 1", (int(round_no), str(phase)))
    conn.commit()


def set_game_over(conn: sqlite3.Connection, *, winner_country: str, winner_round: int, reason: str = "win_conditions") -> None:
    cur = conn.cursor()
    cur.execute("""
        UPDATE game_meta
        SET phase = 'game_over',
            winner_country = ?,
            winner_round = ?,
            winner_reason = ?
        WHERE id = 1
    """, (str(winner_country), int(winner_round), str(reason)))
    conn.commit()


def clear_game_over(conn: sqlite3.Connection) -> None:
    cur = conn.cursor()
    cur.execute("""
        UPDATE game_meta
        SET winner_country = NULL,
            winner_round = NULL,
            winner_reason = NULL
        WHERE id = 1
    """)
    conn.commit()


# -----------------------
# Countries CRUD
# -----------------------
def load_country_metrics(conn: sqlite3.Connection, country: str) -> Optional[Dict[str, Any]]:
    cur = conn.cursor()
    cur.execute("""
        SELECT name, military, stability, economy, diplomatic_influence, public_approval, ambition
        FROM countries
        WHERE name = ?
    """, (country,))
    row = cur.fetchone()
    if not row:
        return None
    return {
        "name": row[0],
        "military": int(row[1]),
        "stability": int(row[2]),
        "economy": int(row[3]),
        "diplomatic_influence": int(row[4]),
        "public_approval": int(row[5]),
        "ambition": str(row[6]),
    }


def load_all_country_metrics(conn: sqlite3.Connection, countries: List[str]) -> Dict[str, Dict[str, Any]]:
    out: Dict[str, Dict[str, Any]] = {}
    for c in countries:
        m = load_country_metrics(conn, c)
        if m:
            out[c] = m
    return out


def apply_country_deltas(conn: sqlite3.Connection, country: str, deltas: Dict[str, Any]) -> None:
    dm = int(deltas.get("militär", 0))
    ds = int(deltas.get("stabilität", 0))
    de = int(deltas.get("wirtschaft", 0))
    dd = int(deltas.get("diplomatie", 0))
    dp = int(deltas.get("öffentliche_zustimmung", 0))

    cur = conn.cursor()
    cur.execute("""
        UPDATE countries SET
            military = military + ?,
            stability = stability + ?,
            economy = economy + ?,
            diplomatic_influence = diplomatic_influence + ?,
            public_approval = public_approval + ?
        WHERE name = ?
    """, (dm, ds, de, dd, dp, country))
    conn.commit()

    cur.execute("""
        SELECT military, stability, economy, diplomatic_influence, public_approval
        FROM countries WHERE name = ?
    """, (country,))
    m, s, e, d, p = cur.fetchone()

    cur.execute("""
        UPDATE countries SET
            military = ?, stability = ?, economy = ?, diplomatic_influence = ?, public_approval = ?
        WHERE name = ?
    """, (clamp_int(m), clamp_int(s), clamp_int(e), clamp_int(d), clamp_int(p), country))
    conn.commit()


def insert_turn_history(
    conn: sqlite3.Connection,
    *,
    country: str,
    round_no: int,
    action_public: str,
    global_context: str,
    deltas: Dict[str, Any],
) -> None:
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO turn_history (
            country, round, action_public, global_context,
            delta_military, delta_stability, delta_economy, delta_diplomatic_influence, delta_public_approval
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    """, (
        country,
        int(round_no),
        str(action_public),
        str(global_context),
        int(deltas.get("militär", 0)),
        int(deltas.get("stabilität", 0)),
        int(deltas.get("wirtschaft", 0)),
        int(deltas.get("diplomatie", 0)),
        int(deltas.get("öffentliche_zustimmung", 0)),
    ))
    conn.commit()


def load_recent_history(conn: sqlite3.Connection, country: str, limit: int = 12) -> List[Tuple]:
    cur = conn.cursor()
    cur.execute("""
        SELECT round, action_public,
               delta_military, delta_stability, delta_economy, delta_diplomatic_influence, delta_public_approval,
               global_context
        FROM turn_history
        WHERE country = ?
        ORDER BY id DESC
        LIMIT ?
    """, (country, int(limit)))
    return cur.fetchall()


# -----------------------
# Snapshots for dashboard
# -----------------------
def upsert_country_snapshot(
    conn: sqlite3.Connection,
    *,
    round_no: int,
    country: str,
    metrics: Dict[str, Any],
    victory_progress: float,
    is_winner: bool,
) -> None:
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO country_snapshots (
            round, country,
            economy, stability, military, diplomatic_influence, public_approval,
            victory_progress, is_winner
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        ON CONFLICT(round, country) DO UPDATE SET
            economy=excluded.economy,
            stability=excluded.stability,
            military=excluded.military,
            diplomatic_influence=excluded.diplomatic_influence,
            public_approval=excluded.public_approval,
            victory_progress=excluded.victory_progress,
            is_winner=excluded.is_winner,
            ts=CURRENT_TIMESTAMP
    """, (
        int(round_no),
        str(country),
        int(metrics["economy"]),
        int(metrics["stability"]),
        int(metrics["military"]),
        int(metrics["diplomatic_influence"]),
        int(metrics["public_approval"]),
        float(victory_progress),
        1 if is_winner else 0,
    ))
    conn.commit()


def get_country_snapshots(conn: sqlite3.Connection, *, limit_rounds: int = 50) -> List[Dict[str, Any]]:
    cur = conn.cursor()
    cur.execute("""
        SELECT round, country, economy, stability, military, diplomatic_influence, public_approval, victory_progress, is_winner, ts
        FROM country_snapshots
        ORDER BY round ASC, country ASC
    """)
    rows = cur.fetchall()
    out: List[Dict[str, Any]] = []
    for r in rows:
        out.append({
            "round": int(r[0]),
            "country": str(r[1]),
            "economy": int(r[2]),
            "stability": int(r[3]),
            "military": int(r[4]),
            "diplomatic_influence": int(r[5]),
            "public_approval": int(r[6]),
            "victory_progress": float(r[7]),
            "is_winner": bool(int(r[8])),
            "ts": str(r[9]),
        })
    return out


# -----------------------
# Round Actions + Locks
# -----------------------
def clear_round_data(conn: sqlite3.Connection, round_no: int) -> None:
    cur = conn.cursor()
    cur.execute("DELETE FROM round_actions WHERE round = ?", (int(round_no),))
    cur.execute("DELETE FROM round_locks WHERE round = ?", (int(round_no),))
    conn.commit()


def upsert_round_actions(conn: sqlite3.Connection, round_no: int, country: str, actions_obj: Dict[str, Any]) -> None:
    """
    Save action_text per variant + impact_json (folgen).
    """
    cur = conn.cursor()
    for variant in ("aggressiv", "moderate", "passiv"):
        text = str(actions_obj[variant]["aktion"])
        folgen = actions_obj[variant].get("folgen", {}) or {}
        impact_json = json.dumps(folgen, ensure_ascii=False)

        cur.execute("""
            INSERT INTO round_actions (round, country, variant, action_text, impact_json)
            VALUES (?, ?, ?, ?, ?)
            ON CONFLICT(round, country, variant) DO UPDATE SET
                action_text = excluded.action_text,
                impact_json = excluded.impact_json
        """, (int(round_no), country, variant, text, impact_json))
    conn.commit()


def get_round_actions(conn: sqlite3.Connection, round_no: int) -> Dict[str, Dict[str, str]]:
    cur = conn.cursor()
    cur.execute("""
        SELECT country, variant, action_text
        FROM round_actions
        WHERE round = ?
    """, (int(round_no),))
    out: Dict[str, Dict[str, str]] = {}
    for country, variant, action_text in cur.fetchall():
        out.setdefault(str(country), {})[str(variant)] = str(action_text)
    return out


def get_round_action_impacts(conn: sqlite3.Connection, round_no: int) -> Dict[str, Dict[str, Dict[str, Any]]]:
    """
    returns: {country: {variant: folgen_dict}}
    """
    cur = conn.cursor()
    cur.execute("""
        SELECT country, variant, impact_json
        FROM round_actions
        WHERE round = ?
    """, (int(round_no),))
    out: Dict[str, Dict[str, Dict[str, Any]]] = {}
    for country, variant, impact_json in cur.fetchall():
        folgen = {}
        if impact_json:
            try:
                folgen = json.loads(impact_json)
            except Exception:
                folgen = {}
        out.setdefault(str(country), {})[str(variant)] = folgen
    return out


def lock_choice(conn: sqlite3.Connection, round_no: int, country: str, variant: str) -> None:
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO round_locks (round, country, locked_variant)
        VALUES (?, ?, ?)
        ON CONFLICT(round, country) DO UPDATE SET locked_variant = excluded.locked_variant, locked_at = CURRENT_TIMESTAMP
    """, (int(round_no), country, str(variant)))
    conn.commit()


def get_locks(conn: sqlite3.Connection, round_no: int) -> Dict[str, str]:
    cur = conn.cursor()
    cur.execute("""
        SELECT country, locked_variant
        FROM round_locks
        WHERE round = ?
    """, (int(round_no),))
    return {str(c): str(v) for c, v in cur.fetchall()}


def all_locked(conn: sqlite3.Connection, round_no: int, countries: List[str]) -> bool:
    locks = get_locks(conn, round_no)
    return all(c in locks for c in countries)


# -----------------------
# Round Summaries (Memory)
# -----------------------
def upsert_round_summary(conn: sqlite3.Connection, round_no: int, summary: str) -> None:
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO round_summaries (round, summary)
        VALUES (?, ?)
        ON CONFLICT(round) DO UPDATE SET summary = excluded.summary, ts = CURRENT_TIMESTAMP
    """, (int(round_no), str(summary)))
    conn.commit()


def get_recent_round_summaries(conn: sqlite3.Connection, limit: int = 3) -> List[Tuple[int, str]]:
    cur = conn.cursor()
    cur.execute("""
        SELECT round, summary
        FROM round_summaries
        ORDER BY round DESC
        LIMIT ?
    """, (int(limit),))
    return [(int(r), str(s)) for r, s in cur.fetchall()]


def clear_all_round_summaries(conn: sqlite3.Connection) -> None:
    cur = conn.cursor()
    cur.execute("DELETE FROM round_summaries")
    conn.commit()


# -----------------------
# External events (USA/China/Russia)
# -----------------------
def clear_external_events(conn: sqlite3.Connection, round_no: int) -> None:
    cur = conn.cursor()
    cur.execute("DELETE FROM external_events WHERE round = ?", (int(round_no),))
    conn.commit()


def upsert_external_event(
    conn: sqlite3.Connection,
    round_no: int,
    actor: str,
    headline: str,
    modifiers: Dict[str, Any],
    *,
    quote: str = "",
    craziness: int = 0,
) -> None:
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO external_events (round, actor, headline, modifiers_json, quote, craziness)
        VALUES (?, ?, ?, ?, ?, ?)
        ON CONFLICT(round, actor) DO UPDATE SET
            headline = excluded.headline,
            modifiers_json = excluded.modifiers_json,
            quote = excluded.quote,
            craziness = excluded.craziness
    """, (
        int(round_no),
        str(actor),
        str(headline),
        json.dumps(modifiers, ensure_ascii=False),
        str(quote),
        int(craziness),
    ))
    conn.commit()


def get_external_events(conn: sqlite3.Connection, round_no: int) -> List[Dict[str, Any]]:
    cur = conn.cursor()
    cur.execute("""
        SELECT actor, headline, modifiers_json, quote, craziness
        FROM external_events
        WHERE round = ?
        ORDER BY actor ASC
    """, (int(round_no),))
    out: List[Dict[str, Any]] = []
    for actor, headline, mj, quote, craziness in cur.fetchall():
        try:
            modifiers = json.loads(mj)
        except Exception:
            modifiers = {}
        out.append({
            "actor": str(actor),
            "headline": str(headline),
            "modifiers": modifiers,
            "quote": str(quote or ""),
            "craziness": int(craziness or 0),
        })
    return out


# -----------------------
# Auth (PBKDF2 + pepper)
# -----------------------
def _get_pepper() -> bytes:
    pepper = (os.getenv("APP_AUTH_PEPPER") or "").strip()
    if not pepper:
        raise RuntimeError("APP_AUTH_PEPPER fehlt in .env")
    return pepper.encode("utf-8")


def _hash_password(password: str, *, salt: bytes) -> str:
    pepper = _get_pepper()
    pw = password.encode("utf-8") + b"|" + pepper
    dk = hashlib.pbkdf2_hmac("sha256", pw, salt, 200_000, dklen=32)
    return base64.b64encode(salt).decode("ascii") + "$" + base64.b64encode(dk).decode("ascii")


def create_user(conn: sqlite3.Connection, *, username: str, password: str, role: str, country: str | None = None) -> None:
    username = username.strip()
    if not username:
        raise ValueError("username leer")
    if role not in ("gm", "player"):
        raise ValueError("role muss 'gm' oder 'player' sein")
    if role == "player" and not country:
        raise ValueError("player braucht country")
    if role == "gm":
        country = None

    salt = os.urandom(16)
    pw_hash = _hash_password(password, salt=salt)

    cur = conn.cursor()
    cur.execute("""
        INSERT INTO users (username, password_hash, role, country)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(username) DO UPDATE SET
          password_hash=excluded.password_hash,
          role=excluded.role,
          country=excluded.country
    """, (username, pw_hash, role, country))
    conn.commit()


def verify_user(conn: sqlite3.Connection, *, username: str, password: str) -> dict | None:
    cur = conn.cursor()
    cur.execute("SELECT username, password_hash, role, country FROM users WHERE username=?", (username.strip(),))
    row = cur.fetchone()
    if not row:
        return None

    u, pw_hash, role, country = row
    try:
        salt_b64, _dk_b64 = pw_hash.split("$", 1)
        salt = base64.b64decode(salt_b64.encode("ascii"))
        expected = _hash_password(password, salt=salt)
    except Exception:
        return None

    if expected != pw_hash:
        return None

    return {"username": str(u), "role": str(role), "country": (str(country) if country else None)}


def list_users(conn: sqlite3.Connection) -> list[dict]:
    cur = conn.cursor()
    cur.execute("SELECT username, role, country, created_at FROM users ORDER BY role DESC, username ASC")
    out = []
    for u, r, c, ca in cur.fetchall():
        out.append({"username": str(u), "role": str(r), "country": (str(c) if c else None), "created_at": str(ca)})
    return out


def delete_user(conn: sqlite3.Connection, username: str) -> None:
    cur = conn.cursor()
    cur.execute("DELETE FROM users WHERE username=?", (username.strip(),))
    conn.commit()


def get_max_snapshot_round(conn: sqlite3.Connection) -> Optional[int]:
    cur = conn.cursor()
    cur.execute("SELECT MAX(round) FROM country_snapshots")
    r = cur.fetchone()[0]
    return int(r) if r is not None else None


def clear_country_snapshots(conn: sqlite3.Connection) -> None:
    cur = conn.cursor()
    cur.execute("DELETE FROM country_snapshots")
    conn.commit()

def clear_domestic_events(conn: sqlite3.Connection, round_no: int) -> None:
    cur = conn.cursor()
    cur.execute("DELETE FROM domestic_events WHERE round = ?", (int(round_no),))
    conn.commit()


def upsert_domestic_event(
    conn: sqlite3.Connection,
    round_no: int,
    country: str,
    headline: str,
    *,
    details: str = "",
    craziness: int = 0,
) -> None:
    cur = conn.cursor()
    cur.execute("""
        INSERT INTO domestic_events (round, country, headline, details, craziness, created_at)
        VALUES (?, ?, ?, ?, ?, strftime('%s','now'))
        ON CONFLICT(round, country) DO UPDATE SET
            headline = excluded.headline,
            details = excluded.details,
            craziness = excluded.craziness,
            created_at = strftime('%s','now')
    """, (int(round_no), str(country), str(headline), str(details), int(craziness)))
    conn.commit()


def get_domestic_events(conn: sqlite3.Connection, round_no: int) -> List[Dict[str, Any]]:
    cur = conn.cursor()
    cur.execute("""
        SELECT country, headline, details, craziness, created_at
        FROM domestic_events
        WHERE round = ?
        ORDER BY country ASC
    """, (int(round_no),))
    out: List[Dict[str, Any]] = []
    for country, headline, details, craziness, created_at in cur.fetchall():
        out.append({
            "country": str(country),
            "headline": str(headline),
            "details": str(details or ""),
            "craziness": int(craziness or 0),
            "created_at": int(created_at or 0),
        })
    return out

def clear_all_events_and_history(conn: sqlite3.Connection) -> None:
    cur = conn.cursor()
    cur.execute("DELETE FROM turn_history")
    cur.execute("DELETE FROM external_events")
    cur.execute("DELETE FROM domestic_events")
    cur.execute("DELETE FROM round_actions")
    cur.execute("DELETE FROM round_locks")
    conn.commit()
